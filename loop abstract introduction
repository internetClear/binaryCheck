探索高精度软件检测的最大障碍----循环总结工具


	为什么漏洞总是无穷无尽？
	为什么源代码检测总是有太多的误报和漏报？
	为什么fuzz测试总是有太多的漏报？
这些问题很多安全行业的人都面临过，也能谈很多。今天我们关注的是最底层的问题----循环（和递归），笔者认为这是软件漏洞难以灭绝的根源。
为什么是循环（和递归）？因为循环（和递归）导致了程序的复杂度大大增加。相较于循环（和递归），软件的结构性、逻辑性漏洞虽难但少，用人工解决合宜。但是软件本身的问题却不一样：可以想象，假如没有循环（和递归）：程序分析检测用符号执行可以精确的推理分析，这样源代码静态分析检测工具就会大大提高分析精确度，从源代码层面就不存在大量的误报和漏报了。没有循环和递归，条件判断虽然仍然会导致程序执行路径大大增加，但是控制好条件判断就解决问题了，这样fuzz测试就能减少漏报。
但是循环（和递归）至今没有很好的解决办法，所有的分析还停留在学术分析阶段，没有真正工业级的应用存在。在学术界，循环分析的主要手段是循环总结（递归类似）。最近几年循环总结有进步，但是都是针对特定类型的简单功能的循环，或者说典型的循环，较通用的循环总结还是很少见。查阅近几年的研究成果，较典型是国内一优秀百篇中的研究，好像为此还发了几篇较好的论文。但是该研究的适应性也不是很好。
从商业化产品的实际应用看，循环和递归分析的误报、漏报都很高。笔者对某知名开源代码分析工具（编译器）做过测试，其循环分析仅关注第0、1、2、n等4轮的代码；某知名商业化源代码静态分析只关注有限轮次的循环代码分析。
笔者一直梦想做高精度的程序分析检测工具，围绕这个目标做了些工作。如前期公众号上的二进制指令分析、fuzz效率评估改进；到符号执行算法实现等等（这几个后面我们将单独介绍）；再到源代码的存储、查询，慢慢的，我们打造了一套独特的、涵盖源代码和二进制的、动静态结合程序分析检测工具体系雏形，而且是自主可控的，纯手工打造（当然还有待完善）。但是，在大规模程序分析中，速度、效果、规模一直是难题，记得网上有人将程序分析检测的时间、空间、效果三者作为相互制约的因素。这个问题个人认为需进一步辨识：如果只是单纯的程序规模扩张，通过并发、多处理器等应该可以解决。这些已经有很好的研究成果可以借鉴采用。但是，对于循环、递归、函数深度嵌套调用，则不是时间或空间的拓展可以解决的。目前较认可的主流解决方案是总结（也有称为摘要）。
笔者学习了大量的国内外研究成果，惊叹于作者的创新能力和细致的工作。但是，现有研究不能匹配我们独特的程序分析体系，不能满足我们系统设计要求。针对这个问题，我们试图独立开发一个循环总结工具。
国内外对循环总结都还没有明确的定义规范，不同的人根据不同的程序分析目标和技术理解做不同的研究和创新尝试（其实这也是工程技术研究的魅力所在）。由于没有明确的具体目标要求，笔者对循环总结花费了很长的时间：搞清楚分析的目标对象、分析的描述形式、算法实现方式等都要反复论证；还要结合现有研究成果论证算法的有效性、从数学角度分析算法的可行性分析，就算是总结结果的形态展示，我们都要反复考虑。围绕循环总结，我们设计了几十个算法，反复的推倒重来；作废的算法代码估计有1w+。
最终，我们设计了一个循环总结的实现方案，给出了算法，并实现了相关工具。工具正在测试，完善后根据需要我们可能将提交到Github上。从具体效果看，对现有典型的，或者说简单的循环基本都能给出大概的描述形式；更重要的是，对于复杂的循环，我们的算法也能初步达到既定目标。当然，还有很多问题待进一步研究。
如果说循环总结是拦在高精度程序分析前的最后一座大山，那我们已经把这座大山炼化为一个石头，希望他是一个吸天地之灵气的混沌元石，下一步，我们能在程序分析的大潮下把这个石头打磨成个灵明石猴。
由于循环总结工具过于小众，我们还没有收集到国内外同类型工具的信息，也没法做对标分析。如果有同行能提供相关信息，不胜感激。
下一步，我们将应用这些东西做个不一样的东西。敬请关注！
